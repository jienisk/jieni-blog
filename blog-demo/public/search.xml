<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sora 2 视频去水印！免费在线平台+本地离线部署！完全免费开源</title>
      <link href="/article/%E8%A7%86%E9%A2%91%E5%8E%BB%E6%B0%B4%E5%8D%B0/"/>
      <url>/article/%E8%A7%86%E9%A2%91%E5%8E%BB%E6%B0%B4%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Sora-2-视频去水印！免费在线平台-本地离线部署！完全免费开源"><a href="#Sora-2-视频去水印！免费在线平台-本地离线部署！完全免费开源" class="headerlink" title="Sora 2 视频去水印！免费在线平台+本地离线部署！完全免费开源"></a>Sora 2 视频去水印！免费在线平台+本地离线部署！完全免费开源</h1><p>Sora 2 视频生成最近非常火热，任何人只需动动鼠标就能轻松在线生成神奇又有趣的视频。但生成的视频通常会带有水印。如果你想彻底去除这些烦人的水印，可以通过在线去水印平台，或者自己通过免费开源项目在本地部署实现！</p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADFGkBBo9iZOBh94uKIiXCoJTeHXPyAAImDWsbkrQIVBSgPKqM4-0MAQADAgADdwADNgQ.jpg" alt="图片"></p><p>下面是我收集并亲自体验过真正能轻松去除 sora 2视频水印的网站：</p><p>1.Removesorawatermark<a href="https://www.removesorawatermark.online/">（链接直达）</a>- 10 个免费额度</p><p>2.remove-sora-watermark<a href="https://reel.money/tools/remove-sora-watermark">（链接直达）</a>- 20 个免费额度</p><p>3.removesorawatermark.pro<a href="https://www.removesorawatermark.pro/zh">（链接直达）</a>- 2 个额度</p><p>4.nosorawm<a href="https://nosorawm.app/zh">（链接直达）</a>- 约 2+ 个额度</p><p>5.unwatermark<a href="https://unwatermark.ai/">（链接直达）</a>- 3 个额度</p><p>6.watermark-removal<a href="https://sora2u.com/watermark-removal">（链接直达）</a>- 3 个额度</p><p>7.sora-watermark-remover<a href="https://www.topyappers.com/tools/sora-watermark-remover">（链接直达）</a></p><p>如果不想受额度限制，建议直接本地部署。推荐使用 GitHub 上的开源项目：<a href="https://github.com/linkedlist771/SoraWatermarkCleaner">SoraWatermarkCleaner</a>。自己在电脑上安装更方便！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AI 答题平台（前端）</title>
      <link href="/article/AI%E7%AD%94%E9%A2%98-react/"/>
      <url>/article/AI%E7%AD%94%E9%A2%98-react/</url>
      
        <content type="html"><![CDATA[<h1 id="从0到1建造AI答题平台（前端）"><a href="#从0到1建造AI答题平台（前端）" class="headerlink" title="从0到1建造AI答题平台（前端）"></a>从0到1建造AI答题平台（前端）</h1><p>利用 vite 创建前端工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest my-app</span><br></pre></td></tr></table></figure><p>引入arco-design框架</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @arco-design/web-react</span><br></pre></td></tr></table></figure><p>引入reaact&#x3D;router</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom</span><br></pre></td></tr></table></figure><p>先在<code>main.tsx</code>里面用严格模式+BrowserRouter包裹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createRoot(document.getElementById(&#x27;root&#x27;)!).render(</span><br><span class="line">  &lt;StrictMode&gt;</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">      &lt;App /&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">  &lt;/StrictMode&gt;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>先创建GlobalHeader.ts，在arco-design组件库里找到合适组件，然后修改，这里需要引入routes.ts，我们需要对routes里面设置的路由信息做解析，可以用map方法遍历渲染到导航栏上，然后去定义方法，先定义useLocation，再用里面的pathname去获取url，然后把location.pathname赋值给一个变量，然后在return里面用selectedKeys &#x3D; {你定义的变量}去让组件显示出被选中的状态高亮，这里在map遍历时的routes属性要注意ts的类型转换，还要做一些条件判断，避免&#x2F;和&#x2F;home出现选中出错问题，最后导出组件即可。</p><p>然后创建BasicLayout.tsx组件，作为基础布局，在arco-design组件库里找到合适组件，然后修改，可以使用<code>useRoutes(routes)</code>方法渲染出路由。可以创建index.css除了userLayout布局之外的全局的css来应用样式。</p><p>然后创建UserLayout.tsx组件，作为用户布局，在arco-design组件库里找到合适组件，然后修改，用<Outlet />渲染内容，可以创建UserLayout.module.css来应用用户布局的样式。</p><p>routes.ts配置，用ts的写法，所以不能写element（这是tsx的语法）,注意ts的类型检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       path: &#x27;/user&#x27;,</span><br><span class="line">       name: &#x27;用户&#x27;,</span><br><span class="line">       layout: UserLayout,</span><br><span class="line">       meta: &#123;</span><br><span class="line">           hideInMenu: true,</span><br><span class="line">       &#125;,</span><br><span class="line">       children: [</span><br><span class="line">           &#123;</span><br><span class="line">               path: &#x27;login&#x27;,</span><br><span class="line">               name: &#x27;用户登录&#x27;,</span><br><span class="line">               Component: UserLoginPage,</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               path: &#x27;register&#x27;,</span><br><span class="line">               name: &#x27;用户注册&#x27;,</span><br><span class="line">               Component: UserRegisterPage,</span><br><span class="line">           &#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><p>在定义路由时，因为需要定义类型，但是原有的类型可能不足，这个时候可以自定义interface，或者使用类型交叉，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    type CustomRouteObject = RouteObject &amp; &#123;</span><br><span class="line">    name?: string;  // 类型交叉只能使用type，不能使用interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App.tsx入口文件，可以使用useLocation()，再用location.pathname.startsWith(‘&#x2F;user’)来匹配用户布局，在通过三元表达式<code>&#123;isUserRoute ? &lt;UserLayout /&gt; : &lt;BasicLayout /&gt; &#125;</code>来切换不同的布局。</p><p>定义全局状态管理，使用useContext+useState来进行全局状态管理，首先创建一个contexts文件夹，里面创建userContext.tsx,先createContext()定义一个自定义变量，然后useState()定义状态管理，之后定义UserContext()组件（这里一定要注意开头要大写），里面写自己要用的方法，参数中传递{children}，然后用return导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">        &lt;UserContext.Provider value=&#123;&#123;loginUser, setLoginUser, fetchLoginUser&#125;&#125;&gt;</span><br><span class="line">            &#123;children&#125;</span><br><span class="line">        &lt;/UserContext.Provider&gt;</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>现在我们就定义好了一个全局状态管理，想用的时候，在所需页面使用useContext()导入，然后解构你要用的方法，直接调用即可。</p><p>现在我们做全局权限管理，定义三个文件 accexxEnum.ts  checkAccess.ts  index.ts,<br>accexxEnum.ts 定义权限枚举，checkAccess.ts 写权限校验逻辑，index.ts 定义在进入页面之前的权限校验和结果处理。</p><p>登录页面（UserLoginPage.tsx）：首先去框架官网找一个适合的登录组件，然后修改，记住这个框架的特点是react都用首字母大写的驼峰写法，vue都用a-连接的写法。</p><p>然后在定义登录页面的逻辑，先用useState(参数是一个对象，对象里面定义两个默认值都为’’)定义form、setForm，在定义useContext(UserContext)，定义useNavigate()，然后在定义handleSubmit()，用异步等待写法，里面调用接口定义好的userLoginUsingPost(form)，传入form变量作为参数，然后做判断，如果成功，就navigate(‘&#x2F;‘,{replace: true})跳转到首页，如果失败，就提示错误信息。之后定义handleInputChange()，用来获取输入框输入的内容，从而更新列表。注册界面同理。</p><p>用户管理页面（AdminUserPage.tsx）:首先去框架官网找一个适合的table组件做表单，找一个适合form组件做搜索框，然后去routes.ts里面配置路由，主要用户管理只有管理员能看见，需要给管理员权限，然后写方法，用useState()定义formSearchParams、searchParams、dataList、total状态和它们的set，定义loadData()来获取数据（调用listUserByPageUsingPost(searchParams)接口，做成功和失败的判断，成功就给表单赋值），可以用useEffect()来监听searchParams变化，只要变化就调用loadData(),然后我们可以定义删除方法，搜索方法，onPageChange方法，都差不多，大同小异，然后在配置columns，里面对应的都是数据库的字段，这里主要你要想做一些转换可以使用render：() &#x3D;&gt; 转化的组件或方法，然后在return里面配置对应的变量，就可以实现这个页面的展示和全部功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Form onSubmit=&#123;doSearch&#125; style=&#123;&#123; marginBottom: &#x27;20px&#x27; &#125;&#125; layout=&#x27;inline&#x27; autoComplete=&quot;off&quot;&gt;</span><br><span class="line">            &lt;FormItem label=&#x27;用户名&#x27;&gt;</span><br><span class="line">                &lt;Input allowClear value=&#123;formSearchParams.userName&#125; placeholder=&#x27;请输入用户名&#x27; onChange=&#123;(value) =&gt;</span><br><span class="line">                    setFormSearchParams(prev =&gt; (&#123;...prev, userName: value&#125;))</span><br><span class="line">                &#125;/&gt;</span><br><span class="line">            &lt;/FormItem&gt;</span><br><span class="line">            &lt;FormItem label=&#x27;用户名&#x27;&gt;</span><br><span class="line">                &lt;Input allowClear value=&#123;formSearchParams.userProfile&#125; placeholder=&#x27;请输入用户简介&#x27; onChange=&#123;(value) =&gt;</span><br><span class="line">                    setFormSearchParams(prev =&gt; (&#123;...prev, userProfile: value&#125;))</span><br><span class="line">                &#125;/&gt;</span><br><span class="line">            &lt;/FormItem&gt;</span><br><span class="line">            &lt;FormItem wrapperCol=&#123;&#123; offset: 5 &#125;&#125;&gt;</span><br><span class="line">                &lt;Button size=&#x27;large&#x27; type=&#x27;primary&#x27; htmlType=&#x27;submit&#x27;&gt;搜索&lt;/Button&gt;</span><br><span class="line">            &lt;/FormItem&gt;</span><br><span class="line">        &lt;/Form&gt;</span><br><span class="line"></span><br><span class="line">        &lt;Table columns=&#123;columns&#125; data=&#123;dataList&#125; pagination=&#123;&#123;</span><br><span class="line">          showTotal: true,</span><br><span class="line">          pageSize: searchParams.pageSize,</span><br><span class="line">          current: searchParams.current,</span><br><span class="line">          total,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">          onChange=&#123;onPageChange&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cloudflare 搭建无尽的免费代理节点！高速、不限量，海量优选IP可供自由切换！</title>
      <link href="/article/%E6%90%AD%E5%BB%BA%E6%97%A0%E5%B0%BD%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E8%8A%82%E7%82%B9/"/>
      <url>/article/%E6%90%AD%E5%BB%BA%E6%97%A0%E5%B0%BD%E5%85%8D%E8%B4%B9%E4%BB%A3%E7%90%86%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="Cloudflare-搭建无尽的免费代理节点！高速、不限量，海量优选IP可供自由切换！"><a href="#Cloudflare-搭建无尽的免费代理节点！高速、不限量，海量优选IP可供自由切换！" class="headerlink" title="Cloudflare 搭建无尽的免费代理节点！高速、不限量，海量优选IP可供自由切换！"></a>Cloudflare 搭建无尽的免费代理节点！高速、不限量，海量优选IP可供自由切换！</h1><p>Cloudflare 改版后我们又来搞事情，继续薅资本主义的羊毛，利用CF workers 搭建海量的代理节点！速度还不错，关键是的优选IP地址后速度极快！可以秒开4K、8K视频。</p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADDWkAAf_Jkn0rIb2gc6EiMRk6xKdpAAMdDWsbkrQIVBHXEIcYZcwtAQADAgADdwADNgQ.jpg" alt="图片"></p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADDmkBAAFO8qjheKkxLwsAAVAyGh8p5sMAAh4NaxuStAhUVGSNgkdK3FgBAAMCAAN3AAM2BA.jpg" alt="图片"></p><p>接下来我们就来详细说下部署步骤：</p><p>1、注册并登入Cloudflare账户，建议使用新号 <a href="https://www.cloudflare.com/zh-cn/">【链接直达】</a>，在里面创建 Workers 并 绑定KV空间</p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADD2kBAaL9LSchAf5tZGAQdCURZm28AAIgDWsbkrQIVAucwC5F_s_kAQADAgADdwADNgQ.jpg" alt="图片"></p><p>2、绑定域名，你可以使用免费域名或自己的域名都可以</p><p>3、获取一键部署代码，它是一款开源项目，含加密和明文代码，可自由选择 <a href="https://github.com/byJoey/cfnew">【点击获取】</a></p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADEGkBAksvLI3P64oKB7xE4lHa4A6EAAIhDWsbkrQIVKUamsSH_KCuAQADAgADdwADNgQ.jpg" alt="图片"></p><p>部署登入以后就可以在里面自由创建你需要的CF代理节点，并且可以根据不同的国家或地区进行筛选，建议选择就近原则，速度会更快！</p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADEWkBAqjHVpRkXxeeivH4VWHUsthaAAIiDWsbkrQIVBRiCQ5xhos-AQADAgADdwADNgQ.jpg" alt="图片"></p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADEmkBAvj7kaxB0z6Cf7juZ93SsvGEAAIkDWsbkrQIVA7hyZXed-sTAQADAgADdwADNgQ.jpg" alt="图片"></p><p>最好来一张测速截图，相当的给力！下载速度可以飙到738M左右</p><p><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADDWkAAf_Jkn0rIb2gc6EiMRk6xKdpAAMdDWsbkrQIVBHXEIcYZcwtAQADAgADdwADNgQ.jpg" alt="图片"></p>]]></content>
      
      
      <categories>
          
          <category> 技术类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用快捷键</title>
      <link href="/article/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/article/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="vocode快捷键"><a href="#vocode快捷键" class="headerlink" title="vocode快捷键"></a>vocode快捷键</h2><p>全局替换：Ctrl+Shift+H</p><p>全局搜索文件：Ctrl + P</p><p>重构：F2 （万能重命名。修改变量、函数、类名等，所有引用处同步更改）</p><p>删除行：Ctrl + Shift + K</p><p>复制行到上下方: Alt + Shift + ↑&#x2F;↓</p><p>多选相同词: Ctrl + D</p><p>快速打开文件：Ctrl + P</p><p>选择到行首&#x2F;行尾：Shift + Home&#x2F;End</p><p>我草拟的</p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点心得</title>
      <link href="/article/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%83%E5%BE%97/"/>
      <url>/article/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前端知识点心得"><a href="#前端知识点心得" class="headerlink" title="前端知识点心得"></a>前端知识点心得</h1><h2 id="1-JS中的this指向谁？"><a href="#1-JS中的this指向谁？" class="headerlink" title="1.JS中的this指向谁？"></a>1.JS中的this指向谁？</h2><p>  1.什么是this？</p><ul><li>一个关键字，一个特殊的对象引用</li><li>this 由调用方式决定，运行时绑定</li><li>this的指向是动态的，它的值取决于<strong>函数被调用的方式（简称谁调用它，它就指向谁）</strong></li></ul><p>  2.this的六条核心规则<br>    1. 默认绑定<br>      当函数独立调用（非对象方法、非事件、非构造函数等），this 默认指向 全局对象。<br>      - 非严格模式下：全局对象(window)<br>      - 严格模式下：undefined<br>    2. 隐式绑定(方法调用)<br>      当函数作为对象的方法被调用时，this 指向 调用该方法的对象：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// this 指向 person 对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;John&quot;</span></span><br></pre></td></tr></table></figure><br>    <strong>注意：</strong>隐式丢失陷阱<br>    如果方法被赋值给变量后调用，this 会丢失原对象指向：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = person.<span class="property">sayHi</span>;</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 输出 undefined（严格模式报错）</span></span><br></pre></td></tr></table></figure><br>    3. 显示绑定<br>    场景：通过特定的方法强制指定this<br>    方法：call()、apply()、bind()<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. call/apply 立即调用</span></span><br><span class="line">greet.<span class="title function_">call</span>(user);   <span class="comment">// 输出 &quot;Hello, Bob&quot;</span></span><br><span class="line">greet.<span class="title function_">apply</span>(user);  <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. bind 返回新函数</span></span><br><span class="line"><span class="keyword">const</span> boundFunc = greet.<span class="title function_">bind</span>(user);  <span class="comment">// this 指向绑定user创建的新函数boundFunc</span></span><br><span class="line"><span class="title function_">boundFunc</span>();        <span class="comment">// 输出 &quot;Hello, Bob&quot;</span></span><br></pre></td></tr></table></figure><br>    4. new绑定<br>    场景：构造函数调用，this 指向新创建的对象<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;; （隐式）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="comment">// return this; （隐式）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jerry = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jerry.<span class="property">name</span>); <span class="comment">// &quot;Jerry&quot;</span></span><br></pre></td></tr></table></figure><br>    5. 箭头函数的 this 指向<br>    没有自己的this绑定<br>    箭头函数的 this 继承自外层作用域，且无法被修改<br>    this 捕获的是定义时的环境，而非调用时的环境<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Dave&#x27;</span>,</span><br><span class="line"><span class="attr">sayHi</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// this 指向外层（此处是 window）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">sayHi</span>(); <span class="comment">// 输出 undefined（浏览器中 window.name 为空）</span></span><br></pre></td></tr></table></figure><br>    6. DOM 事件中的 this<br>    在 DOM 事件处理函数中，this 指向 触发事件的元素<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出 &lt;button&gt; 元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>    <code>this绑定规则优先级： new &gt; 显示 &gt; 隐式 &gt; 默认</code>    </p><h2 id="2-JS柯里化函数"><a href="#2-JS柯里化函数" class="headerlink" title="2.JS柯里化函数"></a>2.JS柯里化函数</h2><p>  1.什么是柯里化函数？（Currying）<br>  柯里化是一种将多参数函数转换成一系列单参数函数的技术，它让函数变得更灵活、更易于组合。</p><p>  2.柯里化的核心特点：</p><ul><li>参数分解：每次只接受一个参数，返回新函数处理后续参数<br>多参数 -&gt; 单参数序列</li><li>延迟执行（直到所有参数收集完毕才执行最终计算）、复用性、组合性</li></ul><p>  3.柯里化的实际用途：</p><ul><li>参数复用,动态创建函数，函数组合  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建通用的&quot;问候&quot;函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">greeting</span>) =&gt; <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="title function_">greet</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;Alice&#x27;</span>); <span class="comment">// &quot;Hello, Alice!&quot;</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;Bob&#x27;</span>);   <span class="comment">// &quot;Hello, Bob!&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>  4.柯里化函数实现步骤：</p><ol><li>定义一个接受多个参数的函数</li><li>定义一个返回值为一个函数的函数，接收一个参数（也可接受多个，但是接受多个那为啥还要用柯里化呢）  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通加法函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化转换函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-什么是闭包？"><a href="#3-什么是闭包？" class="headerlink" title="3.什么是闭包？"></a>3.什么是闭包？</h2><p>  闭包就是一个函数可以访问其外部函数及其词法作用域内的变量。 </p><h2 id="4-深入剖析-useEffect-依赖项数组"><a href="#4-深入剖析-useEffect-依赖项数组" class="headerlink" title="4.深入剖析 useEffect 依赖项数组"></a>4.深入剖析 useEffect 依赖项数组</h2><p>  useEffect是一个函数式Hook，允许我们在函数式组件中做一些副作用操作（数据获取、设置订阅、手动更新DOM操作等），依赖项数组是第二个参数，主要作用是控制useEffect的执行时机，只有当数组中的值发生变化时，useEffect才会执行。</p><p>  如果没有传递第二个参数，useEffect在首次渲染和之后的每次更新时，都会执行一次定义个回调函数。</p><p>  如果传递空数组[]，useEffect只会在组件首次渲染时执行一次回调函数，不会在组件更新时执行。如果返回了一个清理函数，那么也会在组件卸载时执行一次。</p><p>  问：useEffect 的回调函数可以是 async？为什么？<br>  答：不可以。async 函数隐式返回 promise,useEffect 期望回调不返回或者返回清理函数，promise 会被当做清理函数。</p><p>  问：如何在useEffect中执行异步操作，比如获取数据？<br>  答：在回调函数内部定义一个async函数，然后立即调用它，这样就能确保useEffect接收的回调是同步的，这个同步回调内部自己处理了异步操作。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ✅ 正确写法：在 useEffect 内部定义并立即调用异步函数</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 1. 定义一个异步函数</span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    const result = await myApi.fetch(&#x27;/api/data&#x27;);</span><br><span class="line">    setData(result);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 2. 立即调用它</span><br><span class="line">  fetchData();</span><br><span class="line">&#125;, []); // 依赖项数组</span><br></pre></td></tr></table></figure><br>  然而，上面的基础写法忽略了一个重要问题：竞态条件（Race Condition）。</p><p>  竞态条件（Race Condition） 指的是两个或多个操作（进程、线程、任务）竞争同一份资源，但最终的执行结果取决于它们执行的精确先后顺序，而这种顺序是不确定的，从而导致无法预测的、常常是错误的的行为。</p><p>  如果组件在数据请求完成之前就被卸载了，或者 useEffect 因为 props 或 state 变化而再次执行，那么第一次请求返回后调用 setData 会更新一个已卸载的组件，导致 React 报内存泄漏警告。</p><p>  因此，更专业、更完整的写法需要包含清理（Cancellation）机制。</p><p>  方案一：使用标志位（Abort Flag）<br>  这是最经典的解决方案，利用组件卸载时 useEffect 的清理函数来阻止设置状态。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  let isMounted = true; // 1. 定义一个标志位，表示组件是否挂载</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    const result = await myApi.fetch(&#x27;/api/data&#x27;);</span><br><span class="line">    if (isMounted) &#123; // 2. 只有在组件仍挂载时才更新状态</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fetchData();</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    isMounted = false; // 3. 清理函数：组件卸载时将标志位设为 false</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>  方案二：使用 AbortController（现代浏览器和 Node.js 支持）<br>  对于真正的网络请求（如 fetch），你可以使用 AbortController 来直接取消请求。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const abortController = new AbortController(); // 1. 创建控制器</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const response = await fetch(&#x27;/api/data&#x27;, &#123;</span><br><span class="line">        signal: abortController.signal, // 2. 将信号注入请求</span><br><span class="line">      &#125;);</span><br><span class="line">      const result = await response.json();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      if (error.name === &#x27;AbortError&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;请求被取消&#x27;); // 捕获因取消产生的错误</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 处理其他真正的错误</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fetchData();</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    abortController.abort(); // 3. 清理函数：取消进行中的请求</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></p><h2 id="5-useTransition-和-useDeferredValue-如何优化用户体验？有何区别？"><a href="#5-useTransition-和-useDeferredValue-如何优化用户体验？有何区别？" class="headerlink" title="5.useTransition 和 useDeferredValue 如何优化用户体验？有何区别？"></a>5.<code>useTransition</code> 和 <code>useDeferredValue</code> 如何优化用户体验？有何区别？</h2><ul><li><code>useTransition</code>: 标记“不那么紧急”的更新<br>  允许将状态更新标记为过渡（transition），降低其优先级<br>  返回<code>isPending</code>（布尔值，表示过渡是否待处理）和<code>startTransition</code>（函数，用于启动过渡，包裹低优先级状态更新）</li><li><code>useDeferredValue</code>: 获取一个“延迟”的值<br>  接受一个值，并返回该值的“延迟”版本，只有当组件紧急更新（比如用户输入）完成后才会更新<br>  核心：提供一个值的“副本”，此副本的更新被推迟，以避免阻塞主渲染进程</li><li><code>useTransition</code>应用场景：搜索 筛选大型列表<br>  因为你在搜索框输入的时候，应该是优先级最高的，比如你在输入时，搜索框底下的列表这时候开始渲染，但是你突然删除了之前的输入框搜索值，重新输入其它值搜索，假如你之前搜索的是一个很大的列表，你肯定不想看到旧的搜索结果还在渲染，你想获取最新的列表，这是就需要将搜索列表设为低优先级。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const [inputValue, setInputValue] = useState(&#x27;&#x27;);</span><br><span class="line">const [searchTerm, setSearchTerm] = useState(&#x27;&#x27;);</span><br><span class="line">const [isPending, startTransiton] = useTransition();</span><br><span class="line"></span><br><span class="line">const handleChange = (e) =&gt; &#123;</span><br><span class="line">  setInputValue(e.target.value); //立即更新</span><br><span class="line">  startTransition(() =&gt; &#123;</span><br><span class="line">    setSearchTerm(e.target.value); //延迟更新</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>useDeferredValue</code>应用场景：外部数据源的图表可视化<br>  图标组件接受频繁更新的data的prop，导致重绘耗时，引发卡顿。这可能就无法控制父组件更新data的时机。<br>  首选<code>useDeferredValue</code>:用于获取data prop的一个延迟版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Chart(&#123; data &#125;) &#123;</span><br><span class="line">  const deferredData = useDeferredValue(data); // 获取延迟版本</span><br><span class="line">  // 使用 deferredData 进行渲染</span><br><span class="line">  return &lt;ExpensiveChartRender data=&#123;deferredData&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  关键区别：<code>useTransition</code>作用于状态更新的过程。<br>  <code>useDeferredValue</code>作用于一个具体的值。</li></ul><h2 id="6-React中的“状态提升”：优缺点是什么？它的边界在哪里？"><a href="#6-React中的“状态提升”：优缺点是什么？它的边界在哪里？" class="headerlink" title="6.React中的“状态提升”：优缺点是什么？它的边界在哪里？"></a>6.React中的“状态提升”：优缺点是什么？它的边界在哪里？</h2><p>  核心思想：当多个组件要共享或反应同一份变化的数据时，将共享状态移至这些组件最近的共同父组件中。</p><p>  目的：1.这些组件都可以访问同一个数据源<br>       2.使多个组件可以反应相同的数据变化<br>       3.保持数据流的单向性与可预测性 </p><p>  缺点：1.Prop Drilling(属性逐层传递)：状态可能需要通过许多中间层组件传递;中间组件被迫接受并传递他们本身并不需要的props.<br>  2.父组件膨胀：最近的共同父组件可能承载过多无关状态和逻辑，变得臃肿。<br>  3.潜在的性能问题：父组件状态更新可能导致所有子组件重新渲染，导致性能问题，需配合React.memo等优化。</p><p>  边界：适用场景：组件层级关系相对简单，少数几个组件共享状态，逻辑清晰，易于维护。但是碰到层级过深或全局状态等复杂场景就不适用了。<br>  替代方案：Context API、状态管理库（Redux、Zustand、Jotai等）</p><h2 id="7-如何用-useContext-useReducer-实现一个轻量级的状态管理器？"><a href="#7-如何用-useContext-useReducer-实现一个轻量级的状态管理器？" class="headerlink" title="7.如何用 useContext + useReducer 实现一个轻量级的状态管理器？"></a>7.如何用 <code>useContext + useReducer</code> 实现一个轻量级的状态管理器？</h2><pre><code>useContext 核心API:React.createContext(): 创建一个上下文(context)对象Context.Provider: 数据提供者，其 value 属性可被后代消费者获取Context.Consumer/useContext: 数据消费者useReducer 核心API：[state, dispatch] = useReducer(reducer, initialArg, init?)reducer 函数：(currentState, action) =&gt; newStatedispatch 函数：触发状态更新，传递action对象。示例：创建一个全局的计数器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const initialState = &#123; count: 0 &#125;;</span><br><span class="line"></span><br><span class="line">function reducer(atate, action)&#123;</span><br><span class="line">  switch(action.type)&#123;</span><br><span class="line">    case &#x27;INCREMENT&#x27;:</span><br><span class="line">      return &#123;...state, count: state.count + 1 &#125;</span><br><span class="line">    case &#x27;DECREMENT&#x27;:</span><br><span class="line">      return &#123;...state, count: state.count - 1 &#125;</span><br><span class="line">    case &#x27;RESET&#x27;:</span><br><span class="line">      return &#123;...state, count: 0 &#125;</span><br><span class="line">    default:</span><br><span class="line">      return state     </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const CountContext = createContext();</span><br><span class="line"></span><br><span class="line">export function CounterProvider(&#123; children &#125;)&#123;</span><br><span class="line">  const [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  return (</span><br><span class="line">    &lt;CounterContext.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;/CounterContext.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function useCounter()&#123;</span><br><span class="line">  const context = useContext(CountContext);</span><br><span class="line">  if(!context) throw new Error(&#x27;useCounter must be used within a CountProvider&#x27;);</span><br><span class="line">  return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; CounterProvider, useCounter &#125; from &#x27;./store&#x27;;</span><br><span class="line"></span><br><span class="line">function DisplayCounter()&#123;</span><br><span class="line">  const &#123; state &#125; = useCounter();</span><br><span class="line">  return &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Controls()&#123;</span><br><span class="line">  const &#123; dispatch &#125; = useCounter();</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;RESET&#x27; &#125;)&#125;&gt;Reset&lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funciton App()&#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;CounterProvider&gt;</span><br><span class="line">      &lt;h1&gt;Counter App&lt;/h1&gt;</span><br><span class="line">      &lt;DisplayCounter /&gt;</span><br><span class="line">      &lt;Controls /&gt;</span><br><span class="line">    &lt;/CounterProvider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h2 id="8-如何在-React-中实现状态的持久化存储？"><a href="#8-如何在-React-中实现状态的持久化存储？" class="headerlink" title="8.如何在 React 中实现状态的持久化存储？"></a>8.如何在 React 中实现状态的持久化存储？</h2><h3 id="什么是状态持久化？"><a href="#什么是状态持久化？" class="headerlink" title="什么是状态持久化？"></a>什么是状态持久化？</h3><p>  核心概念：指将 React 组件或应用的状态数据存储在浏览器之外或浏览器会话之外的某个地方，使得在页面刷新、关闭后依然能够恢复之前的状态。</p><p>  关键目的：提升用户体验，避免数据丢失。       </p><p>  方法一：使用Web Storage API<br>  – <code>localStorage</code>:<br>  数据永久存储，除非用户手动清除浏览器缓存或代码主动删除。<br>  同源下的所有标签页和窗口共享数据。<br>  容量较大（通常为5-10MB）。<br>  – <code>sessionStorage</code>:<br>  数据仅在当前浏览器会话期间有效，关闭标签页或浏览器后数据被清除。<br>  数据仅在当前标签页内可见，不同标签页不共享。<br>  容量与localStorage类似。<br>  方法二：封装自定义Hook(usePersistentState)<br>  目的：将持久化逻辑抽象出来，提高复用性，简化组件代码。<br>  核心思路：<br>  1.内部依然使用 useState 和 useEffect。<br>  2.接受key（存储键名）和 initialValue。<br>  3.返回与 useState 类似的 [state, setState] 数组。<br>  方法三：使用状态管理库的持久化插件<br>  – 场景：项目中已使用如 Redux、Zustand、Recoil 等状态管理库。<br>  – 常用插件：<br>  Redux Persist: 配合Redux使用，可以配置存储引擎（默认localStorage）、黑白名单等。<br>  Zustand Middleware: Zustand提供了persist中间件。<br>  Recoil Persist: 社区提供的Recoil持久化方案。<br>  – 优点：集成方便，配置灵活，通常以处理号序列化等问题。<br>  – 缺点：引入额外依赖，增加包体积。</p><h2 id="9-一个简单的案例看懂useReducer的用法"><a href="#9-一个简单的案例看懂useReducer的用法" class="headerlink" title="9.一个简单的案例看懂useReducer的用法"></a>9.一个简单的案例看懂useReducer的用法</h2><p>  state：当前的状态值，和 useState 返回的一样。</p><p>  dispatch：一个“派发”函数，你用它来发送操作指令（Action）。</p><p>  reducer：一个函数，它决定了如何根据操作指令来更新状态。</p><p>  initialState：状态的初始值。<br>  <figure class="highlight jsx"><figcaption><span>一个简单的计数器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义reducer函数（状态更新逻辑）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">counterReducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;SET&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: action.<span class="property">payload</span> &#125;; <span class="comment">// 使用action带来的数据</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 2. 使用useReducer，传入reducer和初始状态</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(counterReducer, &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Count: &#123;state.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 3. 通过dispatch发送action来更新状态 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;INCREMENT&#x27; &#125;)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;DECREMENT&#x27; &#125;)&#125;&gt;-1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &#x27;SET&#x27;, payload: 100 &#125;)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        Set to 100</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Counter</span>;</span><br></pre></td></tr></table></figure></p><h2 id="10-useRef的用法"><a href="#10-useRef的用法" class="headerlink" title="10.useRef的用法"></a>10.useRef的用法</h2><p>  1.操作真实DOM：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useRef, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">function InputFocus() &#123;</span><br><span class="line">  const inputRef = useRef(null); // 创建 ref</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    inputRef.current.focus(); // 页面加载后聚焦</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  return &lt;input ref=&#123;inputRef&#125; placeholder=&quot;自动聚焦&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2.保存不会触发渲染的变量：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Timer() &#123;</span><br><span class="line">  const countRef = useRef(0);</span><br><span class="line"></span><br><span class="line">  const handleClick = () =&gt; &#123;</span><br><span class="line">    countRef.current += 1;</span><br><span class="line">    console.log(&quot;点击次数：&quot;, countRef.current);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return &lt;button onClick=&#123;handleClick&#125;&gt;点我&lt;/button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  适合保存中间状态、定时器 ID、前一次的值等。</p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cloudflare pages 搭建免费图床!</title>
      <link href="/article/Cloudflare%20pages%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A!/"/>
      <url>/article/Cloudflare%20pages%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A!/</url>
      
        <content type="html"><![CDATA[<h1 id="Cloudflare-pages-搭建免费图床-享受-Telegram-的无限空间"><a href="#Cloudflare-pages-搭建免费图床-享受-Telegram-的无限空间" class="headerlink" title="Cloudflare pages 搭建免费图床! 享受 Telegram 的无限空间"></a>Cloudflare pages 搭建免费图床! 享受 Telegram 的无限空间</h1><p>由于原有的Telegraph API接口被官方关闭，需要将上传渠道切换至Telegram Channel，请按照文档中的部署要求设置<mark>TG_Bot_Token</mark>和<mark>TG_Chat_ID</mark>，否则将无法正常使用上传功能。</p><h2 id="如何获取Telegram的Bot-Token和Chat-ID"><a href="#如何获取Telegram的Bot-Token和Chat-ID" class="headerlink" title="如何获取Telegram的Bot_Token和Chat_ID"></a>如何获取<code>Telegram</code>的<mark>Bot_Token</mark>和<mark>Chat_ID</mark></h2><p>如果您还没有Telegram账户，请先创建一个。接着，按照以下步骤操作以获取<mark>BOT_TOKEN</mark>和<mark>CHAT_ID</mark>：</p><p>1.获取<mark>BOT_TOKEN</mark></p><ul><li>在Telegram中，向@BotFather发送命令&#x2F;newbot，根据提示依次输入您的机器人名称和用户名。成功创建机器人后，您将会收到一个BOT_TOKEN，用于与Telegram API进行交互。</li></ul><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADBmiFGIPZ2Jixr2ymRH0ROMyB1UvVAALHwjEb6w8pVHJprcjeFTihAQADAgADeAADNgQ.png" alt="图片">  </p><p>2.设置机器人为频道管理员</p><ul><li>创建一个新的频道（Channel），进入该频道后，选择频道设置。将刚刚创建的机器人添加为频道管理员，这样机器人才能发送消息。</li></ul><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADB2iFGS5aSynp5fbOw2F6mtWQNNn8AALIwjEb6w8pVAgpIMkU3tygAQADAgADeAADNgQ.png" alt="图片">  </p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADCGiFGXnfPjyc_Y2o94mu_vPaQTHaAALJwjEb6w8pVI07mTPn881tAQADAgADeQADNgQ.png" alt="图片"> </p><p>  3.获取 <mark>chat_ID</mark><br>    - 通过<mark>@VersaToolsBot</mark>获取您的频道ID。向该机器人发送消息，按照指示操作，最后您将得到<mark>CHAT_ID</mark>（即频道的ID）。<br>    - 或者通过@GetTheirIDBot获取您的频道ID。向该机器人发送消息，按照指示操作，最后您将得到CHAT_ID（即频道的ID）。</p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADCWiQ2LDIjYergFSk97ZpLUKrE0EdAAJ1yTEbMbKIVN_1cAnqIHVKAQADAgADeAADNgQ.png" alt="图片"></p><p>  最后去Cloudflare Pages后台设置相关的环境变量（注：修改环境变量后，需要重新部署才能生效）</p><table><thead><tr><th align="center">环境变量</th><th align="center">示例值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">TG_Bot_Token</td><td align="center">123468:AAxxxGKrn5</td><td align="center">从@BotFather获取的Telegram Bot Token。</td></tr><tr><td align="center">TG_Chat_ID</td><td align="center">-1234567</td><td align="center">频道的ID，确保TG Bot是该频道或群组的管理员。</td></tr></tbody></table><h2 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h2><h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><p>  你唯一需要提前准备的就是一个<mark>Cloudflare</mark>账户，如果你还没有，请先注册一个。</p><h3 id="部署教程："><a href="#部署教程：" class="headerlink" title="部署教程："></a>部署教程：</h3><p>  简单3步，即可部署本项目，拥有自己的图床</p><p>  1.下载或Fork本仓库 (注意：目前请使用fork) <a href="https://github.com/cf-pages/Telegraph-Image">【仓库链接】</a></p><p>  2.打开Cloudflare Dashboard，进入Pages管理页面，选择创建项目，如果在第一步中选择的是fork本仓库，则选择<code>连接到 Git 提供程序</code>，如果第一步中选择的是下载本仓库则选择<code>直接上传</code> </p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADCmiQ33qFa_AzNIGUVZ7WrSp7WFnBAAKGyTEbMbKIVGNcpNiiFTBMAQADAgADeQADNgQ.png" alt="图片"></p><p>  3.按照页面提示输入项目名称，选择需要连接的git仓库（第一步选择的是fork）或是上传刚刚下载的仓库文件（第一步选择的是下载本仓库），点击<code>部署站点</code>即可完成部署</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>  1.无限图片储存数量，你可以上传不限数量的图片</p><p>  2.无需购买服务器，托管于Cloudflare的网络上，当使用量不超过Cloudflare的免费额度时，完全免费</p><p>  3.无需购买域名，可以使用Cloudflare Pages提供的<code>*.pages.dev</code>的免费二级域名，同时也支持绑定自定义域名</p><p>  4.支持图片审查API，可根据需要开启，开启后不良图片将自动屏蔽，不再加载</p><p>  5.支持后台图片管理，可以对上传的图片进行在线预览，添加白名单，黑名单等操作</p><h3 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h3><p>  在pages的自定义域里面，绑定cloudflare中存在的域名，在cloudflare托管的域名，自动会修改dns记录 </p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADC2iQ4JplNukEqbHiF0wn8sacV9JrAAKHyTEbMbKIVLwGKUtYn9UYAQADAgADeQADNgQ.png" alt="图片"></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>  1.由于图片文件实际存储于Telegraph，Telegraph限制上传的图片大小最大为5MB</p><p>  2.由于使用Cloudflare的网络，图片的加载速度在某些地区可能得不到保证</p><p>  3.Cloudflare Function免费版每日限制100,000个请求（即上传或是加载图片的总次数不能超过100,000次）, 正常使用已经足够！</p><hr><p>  ✧･ﾟ: <em>✧･ﾟ:</em>  <strong>END</strong>    <em>:･ﾟ✧</em>:･ﾟ✧</p>]]></content>
      
      
      <categories>
          
          <category> 技术类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web式云端电脑？</title>
      <link href="/article/Web%E5%BC%8F%E4%BA%91%E7%AB%AF%E7%94%B5%E8%84%91%EF%BC%9F/"/>
      <url>/article/Web%E5%BC%8F%E4%BA%91%E7%AB%AF%E7%94%B5%E8%84%91%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="无需魔法访问-Google-！堪称Web式的云端电脑？"><a href="#无需魔法访问-Google-！堪称Web式的云端电脑？" class="headerlink" title="无需魔法访问 Google ！堪称Web式的云端电脑？"></a>无需魔法访问 Google ！堪称Web式的云端电脑？</h1><p>无需“魔法”就能访问 Google ？关键时期开源当作备用，查资料方便， 堪称Web式的云端电脑！<br><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADBWiDttXlcjYtusuJH2OfjUNCpKv4AAIMxjEb6w8hVMoVnJ5vSAdoAQADAgADdwADNgQ.jpg" alt="图片"></p><p>Dustinbrett平台：<a href="https://dustinbrett.com/">链接直达</a></p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为啥会焦虑？</title>
      <link href="/article/%E4%B8%BA%E5%95%A5%E4%BC%9A%E7%84%A6%E8%99%91%EF%BC%9F/"/>
      <url>/article/%E4%B8%BA%E5%95%A5%E4%BC%9A%E7%84%A6%E8%99%91%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="为啥会焦虑？"><a href="#为啥会焦虑？" class="headerlink" title="为啥会焦虑？"></a><strong>为啥会焦虑？</strong></h1><ol><li>如果你是一个没心没肺的，你是不会焦虑的，正是因为你想变得更好你才会焦虑，所以这个情绪很正常，每个人都有，正确看待就好，但是不要过量</li><li>不要尝试去控制任何一件事情</li><li>降低期待</li></ol><h1 id="如何保持快乐呢？"><a href="#如何保持快乐呢？" class="headerlink" title="如何保持快乐呢？"></a><del>如何保持快乐呢？</del></h1><ul><li>1.意识到我们人生没有什么事情是永久的，包括你的烦恼</li><li>2.学会感恩  </li><li>3.问问自己 什么是好  什么是坏？都是别人定义的<br>所以你要真正思考你自己想要的是什么，而不是别人或者社会为你定义的，你要明确自己想要的是什么？</li></ul><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      <categories>
          
          <category> 心理学类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 养生 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
