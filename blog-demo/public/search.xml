<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常用快捷键</title>
      <link href="/article/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/article/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><h2 id="vocode快捷键"><a href="#vocode快捷键" class="headerlink" title="vocode快捷键"></a>vocode快捷键</h2><p>全局替换：Ctrl+Shift+H</p><p>全局搜索文件：Ctrl + P</p><p>重构：F2 （万能重命名。修改变量、函数、类名等，所有引用处同步更改）</p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>用户中心管理系统</title>
      <link href="/article/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/article/%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="从0到1建造用户中心管理系统（前端）"><a href="#从0到1建造用户中心管理系统（前端）" class="headerlink" title="从0到1建造用户中心管理系统（前端）"></a>从0到1建造用户中心管理系统（前端）</h1><p>利用 Ant Design Pro 框架创建前端工程</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>使用pro-cli脚手架快速初始化项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 使用 npm</span><br><span class="line">npm i @ant-design/pro-cli -g</span><br><span class="line">pro create myapp</span><br></pre></td></tr></table></figure><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>可以在<strong>config&#x2F;proxy.ts</strong>中配置代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">    // localhost:8000/api/** -&gt; https://preview.pro.ant.design/api/**</span><br><span class="line">    &#x27;/api/&#x27;: &#123;</span><br><span class="line">      // 要代理的地址</span><br><span class="line">      target: &#x27;http://localhost:8080&#x27;,</span><br><span class="line">      // 配置了这个可以从 http 代理到 https</span><br><span class="line">      // 依赖 origin 的功能可能需要这个，比如 cookie</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>记得在api.ts中对应的request方法中的url参数里加上’&#x2F;api&#x2F;‘前缀</p><h2 id="登录-注册页面"><a href="#登录-注册页面" class="headerlink" title="登录&#x2F;注册页面"></a>登录&#x2F;注册页面</h2><p>核心逻辑代码 handleSubmit,用异步等待的方式调用登录接口，values是表单数据，作为登录方法的参数传入，然后做判断，如果成功，提示登录成功，调用fetchUserInfo方法获取用户信息，然后做重定向:<br>const urlParams &#x3D; new URL(window.location.href).searchParams;<br>window.location.href &#x3D; urlParams.get(‘redirect’) || ‘&#x2F;‘;<br>return;<br>根据查询参数中的redirect值来决定用户重定向到哪个页面，如果没有redirect，则默认跳转主页。</p><h2 id="用户管理页面"><a href="#用户管理页面" class="headerlink" title="用户管理页面"></a>用户管理页面</h2><p>  columns对象定义了表格需要展示的每一项列名，与后端接口返回的字段名对应，dataIndex是后端接口返回的字段名，title是表格列名，copyable控制是否可以复制，ellipsis是否可以缩略，tooltip是提示信息，render是自定义渲染函数。<br>  然后在导出的ProTable里传入columns像这样（columns &#x3D; {columns}）就行了，然后传入request函数，在里面用异步等待写法定义searchUsers方法，在将其return，就可以在页面展示用户列表。</p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识点心得</title>
      <link href="/article/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%83%E5%BE%97/"/>
      <url>/article/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前端知识点心得"><a href="#前端知识点心得" class="headerlink" title="前端知识点心得"></a>前端知识点心得</h1><h2 id="1-JS中的this指向谁？"><a href="#1-JS中的this指向谁？" class="headerlink" title="1.JS中的this指向谁？"></a>1.JS中的this指向谁？</h2><p>  1.什么是this？</p><ul><li>一个关键字，一个特殊的对象引用</li><li>this 由调用方式决定，运行时绑定</li><li>this的指向时动态的，它的值取决于<strong>函数被调用的方式（简称谁调用它，它就指向谁）</strong></li></ul><p>  2.this的六条核心规则<br>    1. 默认绑定<br>      当函数独立调用（非对象方法、非事件、非构造函数等），this 默认指向 全局对象。<br>      - 非严格模式下：全局对象(window)<br>      - 严格模式下：undefined<br>    2. 隐式绑定(方法调用)<br>      当函数作为对象的方法被调用时，this 指向 调用该方法的对象：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// this 指向 person 对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// &quot;John&quot;</span></span><br></pre></td></tr></table></figure><br>    <strong>注意：</strong>隐式丢失陷阱<br>    如果方法被赋值给变量后调用，this 会丢失原对象指向：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> func = person.<span class="property">sayHi</span>;</span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// 输出 undefined（严格模式报错）</span></span><br></pre></td></tr></table></figure><br>    3. 显示绑定<br>    场景：通过特定的方法强制指定this<br>    方法：call()、apply()、bind()<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. call/apply 立即调用</span></span><br><span class="line">greet.<span class="title function_">call</span>(user);   <span class="comment">// 输出 &quot;Hello, Bob&quot;</span></span><br><span class="line">greet.<span class="title function_">apply</span>(user);  <span class="comment">// 同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. bind 返回新函数</span></span><br><span class="line"><span class="keyword">const</span> boundFunc = greet.<span class="title function_">bind</span>(user);  <span class="comment">// this 指向绑定user创建的新函数boundFunc</span></span><br><span class="line"><span class="title function_">boundFunc</span>();        <span class="comment">// 输出 &quot;Hello, Bob&quot;</span></span><br></pre></td></tr></table></figure><br>    4. new绑定<br>    场景：构造函数调用，this 指向新创建的对象<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;; （隐式）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="comment">// return this; （隐式）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> jerry = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(jerry.<span class="property">name</span>); <span class="comment">// &quot;Jerry&quot;</span></span><br></pre></td></tr></table></figure><br>    5. 箭头函数的 this 指向<br>    没有自己的this绑定<br>    箭头函数的 this 继承自外层作用域，且无法被修改<br>    this 捕获的是定义时的环境，而非调用时的环境<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;Dave&#x27;</span>,</span><br><span class="line"><span class="attr">sayHi</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// this 指向外层（此处是 window）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">sayHi</span>(); <span class="comment">// 输出 undefined（浏览器中 window.name 为空）</span></span><br></pre></td></tr></table></figure><br>    6. DOM 事件中的 this<br>    在 DOM 事件处理函数中，this 指向 触发事件的元素<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出 &lt;button&gt; 元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>    <code>this绑定规则优先级： new &gt; 显示 &gt; 隐式 &gt; 默认</code>    </p><h2 id="2-JS柯里化函数"><a href="#2-JS柯里化函数" class="headerlink" title="2.JS柯里化函数"></a>2.JS柯里化函数</h2><p>  1.什么是柯里化函数？（Currying）<br>  柯里化是一种将多参数函数转换成一系列单参数函数的技术，它让函数变得更灵活、更易于组合。</p><p>  2.柯里化的核心特点：</p><ul><li>参数分解：每次只接受一个参数，返回新函数处理后续参数<br>多参数 -&gt; 单参数序列</li><li>延迟执行（直到所有参数收集完毕才执行最终计算）、复用性、组合性</li></ul><p>  3.柯里化的实际用途：</p><ul><li>参数复用,动态创建函数，函数组合  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建通用的&quot;问候&quot;函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">greet</span> = (<span class="params">greeting</span>) =&gt; <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="title function_">greet</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;Alice&#x27;</span>); <span class="comment">// &quot;Hello, Alice!&quot;</span></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;Bob&#x27;</span>);   <span class="comment">// &quot;Hello, Bob!&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>  4.柯里化函数实现步骤：</p><ol><li>定义一个接受多个参数的函数</li><li>定义一个返回值为一个函数的函数，接收一个参数（也可接受多个，但是接受多个那为啥还要用柯里化呢）  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通加法函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化转换函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> curried.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args.<span class="title function_">concat</span>(args2));</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> curriedAdd = <span class="title function_">curry</span>(add);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">curriedAdd</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-什么是闭包？"><a href="#3-什么是闭包？" class="headerlink" title="3.什么是闭包？"></a>3.什么是闭包？</h2><p>  闭包就是一个函数可以访问其外部函数及其词法作用域内的变量。 </p><h2 id="4-深入剖析-useEffect-依赖项数组"><a href="#4-深入剖析-useEffect-依赖项数组" class="headerlink" title="4.深入剖析 useEffect 依赖项数组"></a>4.深入剖析 useEffect 依赖项数组</h2><p>  useEffect是一个函数式Hook，允许我们在函数式组件中做一些副作用操作（数据获取、设置订阅、手动更新DOM操作等），依赖项数组是第二个参数，主要作用是控制useEffect的执行时机，只有当数组中的值发生变化时，useEffect才会执行。</p><p>  如果没有传递第二个参数，useEffect在首次渲染和之后的每次更新时，都会执行一次定义个回调函数。</p><p>  如果传递空数组[]，useEffect只会在组件首次渲染时执行一次回调函数，不会在组件更新时执行。如果返回了一个清理函数，那么也会在组件卸载时执行一次。</p><p>  问：useEffect 的回调函数可以是 async？为什么？<br>  答：不可以。async 函数隐式返回 promise,useEffect 期望回调不返回或者返回清理函数，promise 会被当做清理函数。</p><p>  问：如何在useEffect中执行异步操作，比如获取数据？<br>  答：在回调函数内部定义一个async函数，然后立即调用它，这样就能确保useEffect接收的回调是同步的，这个同步回调内部自己处理了异步操作。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// ✅ 正确写法：在 useEffect 内部定义并立即调用异步函数</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  // 1. 定义一个异步函数</span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    const result = await myApi.fetch(&#x27;/api/data&#x27;);</span><br><span class="line">    setData(result);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // 2. 立即调用它</span><br><span class="line">  fetchData();</span><br><span class="line">&#125;, []); // 依赖项数组</span><br></pre></td></tr></table></figure><br>  然而，上面的基础写法忽略了一个重要问题：竞态条件（Race Condition）。</p><p>  竞态条件（Race Condition） 指的是两个或多个操作（进程、线程、任务）竞争同一份资源，但最终的执行结果取决于它们执行的精确先后顺序，而这种顺序是不确定的，从而导致无法预测的、常常是错误的的行为。</p><p>  如果组件在数据请求完成之前就被卸载了，或者 useEffect 因为 props 或 state 变化而再次执行，那么第一次请求返回后调用 setData 会更新一个已卸载的组件，导致 React 报内存泄漏警告。</p><p>  因此，更专业、更完整的写法需要包含清理（Cancellation）机制。</p><p>  方案一：使用标志位（Abort Flag）<br>  这是最经典的解决方案，利用组件卸载时 useEffect 的清理函数来阻止设置状态。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  let isMounted = true; // 1. 定义一个标志位，表示组件是否挂载</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    const result = await myApi.fetch(&#x27;/api/data&#x27;);</span><br><span class="line">    if (isMounted) &#123; // 2. 只有在组件仍挂载时才更新状态</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fetchData();</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    isMounted = false; // 3. 清理函数：组件卸载时将标志位设为 false</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>  方案二：使用 AbortController（现代浏览器和 Node.js 支持）<br>  对于真正的网络请求（如 fetch），你可以使用 AbortController 来直接取消请求。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">  const abortController = new AbortController(); // 1. 创建控制器</span><br><span class="line"></span><br><span class="line">  const fetchData = async () =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const response = await fetch(&#x27;/api/data&#x27;, &#123;</span><br><span class="line">        signal: abortController.signal, // 2. 将信号注入请求</span><br><span class="line">      &#125;);</span><br><span class="line">      const result = await response.json();</span><br><span class="line">      setData(result);</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      if (error.name === &#x27;AbortError&#x27;) &#123;</span><br><span class="line">        console.log(&#x27;请求被取消&#x27;); // 捕获因取消产生的错误</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 处理其他真正的错误</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  fetchData();</span><br><span class="line"></span><br><span class="line">  return () =&gt; &#123;</span><br><span class="line">    abortController.abort(); // 3. 清理函数：取消进行中的请求</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure></p><h2 id="5-useTransition-和-useDeferredValue-如何优化用户体验？有何区别？"><a href="#5-useTransition-和-useDeferredValue-如何优化用户体验？有何区别？" class="headerlink" title="5.useTransition 和 useDeferredValue 如何优化用户体验？有何区别？"></a>5.<code>useTransition</code> 和 <code>useDeferredValue</code> 如何优化用户体验？有何区别？</h2><ul><li><code>useTransition</code>: 标记“不那么紧急”的更新<br>  允许将状态更新标记为过渡（transition），降低其优先级<br>  返回<code>isPending</code>（布尔值，表示过渡是否待处理）和<code>startTransition</code>（函数，用于启动过渡，包裹低优先级状态更新）</li><li><code>useDeferredValue</code>: 获取一个“延迟”的值<br>  接受一个值，并返回该值的“延迟”版本，只有当组件紧急更新（比如用户输入）完成后才会更新<br>  核心：提供一个值的“副本”，此副本的更新被推迟，以避免阻塞主渲染进程</li><li><code>useTransition</code>应用场景：搜索 筛选大型列表<br>  因为你在搜索框输入的时候，应该是优先级最高的，比如你在输入时，搜索框底下的列表这时候开始渲染，但是你突然删除了之前的输入框搜索值，重新输入其它值搜索，假如你之前搜索的是一个很大的列表，你肯定不想看到旧的搜索结果还在渲染，你想获取最新的列表，这是就需要将搜索列表设为低优先级。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const [inputValue, setInputValue] = useState(&#x27;&#x27;);</span><br><span class="line">const [searchTerm, setSearchTerm] = useState(&#x27;&#x27;);</span><br><span class="line">const [isPending, startTransiton] = useTransition();</span><br><span class="line"></span><br><span class="line">const handleChange = (e) =&gt; &#123;</span><br><span class="line">  setInputValue(e.target.value); //立即更新</span><br><span class="line">  startTransition(() =&gt; &#123;</span><br><span class="line">    setSearchTerm(e.target.value); //延迟更新</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>useDeferredValue</code>应用场景：外部数据源的图表可视化<br>  图标组件接受频繁更新的data的prop，导致重绘耗时，引发卡顿。这可能就无法控制父组件更新data的时机。<br>  首选<code>useDeferredValue</code>:用于获取data prop的一个延迟版本  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Chart(&#123; data &#125;) &#123;</span><br><span class="line">  const deferredData = useDeferredValue(data); // 获取延迟版本</span><br><span class="line">  // 使用 deferredData 进行渲染</span><br><span class="line">  return &lt;ExpensiveChartRender data=&#123;deferredData&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  关键区别：<code>useTransition</code>作用于状态更新的过程。<br>  <code>useDeferredValue</code>作用于一个具体的值。</li></ul><h2 id="6-React中的“状态提升”：优缺点是什么？它的边界在哪里？"><a href="#6-React中的“状态提升”：优缺点是什么？它的边界在哪里？" class="headerlink" title="6.React中的“状态提升”：优缺点是什么？它的边界在哪里？"></a>6.React中的“状态提升”：优缺点是什么？它的边界在哪里？</h2><p>  核心思想：当多个组件要共享或反应同一份变化的数据时，将共享状态移至这些组件最近的共同父组件中。</p><p>  目的：1.这些组件都可以访问同一个数据源<br>       2.使多个组件可以反应相同的数据变化<br>       3.保持数据流的单向性与可预测性 </p><p>  缺点：1.Prop Drilling(属性逐层传递)：状态可能需要通过许多中间层组件传递;中间组件被迫接受并传递他们本身并不需要的props.<br>  2.父组件膨胀：最近的共同父组件可能承载过多无关状态和逻辑，变得臃肿。<br>  3.潜在的性能问题：父组件状态更新可能导致所有子组件重新渲染，导致性能问题，需配合React.memo等优化。</p><p>  边界：适用场景：组件层级关系相对简单，少数几个组件共享状态，逻辑清晰，易于维护。但是碰到层级过深或全局状态等复杂场景就不适用了。<br>  替代方案：Context API、状态管理库（Redux、Zustand、Jotai等）</p><h2 id="7-如何用-useContext-useReducer-实现一个轻量级的状态管理器？"><a href="#7-如何用-useContext-useReducer-实现一个轻量级的状态管理器？" class="headerlink" title="7.如何用 useContext + useReducer 实现一个轻量级的状态管理器？"></a>7.如何用 <code>useContext + useReducer</code> 实现一个轻量级的状态管理器？</h2><pre><code>useReducer: useState 的替代方案，适用于更复杂的状态逻辑。</code></pre><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Cloudflare pages 搭建免费图床!</title>
      <link href="/article/Cloudflare%20pages%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A!/"/>
      <url>/article/Cloudflare%20pages%20%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A!/</url>
      
        <content type="html"><![CDATA[<h1 id="Cloudflare-pages-搭建免费图床-享受-Telegram-的无限空间"><a href="#Cloudflare-pages-搭建免费图床-享受-Telegram-的无限空间" class="headerlink" title="Cloudflare pages 搭建免费图床! 享受 Telegram 的无限空间"></a>Cloudflare pages 搭建免费图床! 享受 Telegram 的无限空间</h1><p>由于原有的Telegraph API接口被官方关闭，需要将上传渠道切换至Telegram Channel，请按照文档中的部署要求设置<mark>TG_Bot_Token</mark>和<mark>TG_Chat_ID</mark>，否则将无法正常使用上传功能。</p><h2 id="如何获取Telegram的Bot-Token和Chat-ID"><a href="#如何获取Telegram的Bot-Token和Chat-ID" class="headerlink" title="如何获取Telegram的Bot_Token和Chat_ID"></a>如何获取<code>Telegram</code>的<mark>Bot_Token</mark>和<mark>Chat_ID</mark></h2><p>如果您还没有Telegram账户，请先创建一个。接着，按照以下步骤操作以获取<mark>BOT_TOKEN</mark>和<mark>CHAT_ID</mark>：</p><p>1.获取<mark>BOT_TOKEN</mark></p><ul><li>在Telegram中，向@BotFather发送命令&#x2F;newbot，根据提示依次输入您的机器人名称和用户名。成功创建机器人后，您将会收到一个BOT_TOKEN，用于与Telegram API进行交互。</li></ul><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADBmiFGIPZ2Jixr2ymRH0ROMyB1UvVAALHwjEb6w8pVHJprcjeFTihAQADAgADeAADNgQ.png" alt="图片">  </p><p>2.设置机器人为频道管理员</p><ul><li>创建一个新的频道（Channel），进入该频道后，选择频道设置。将刚刚创建的机器人添加为频道管理员，这样机器人才能发送消息。</li></ul><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADB2iFGS5aSynp5fbOw2F6mtWQNNn8AALIwjEb6w8pVAgpIMkU3tygAQADAgADeAADNgQ.png" alt="图片">  </p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADCGiFGXnfPjyc_Y2o94mu_vPaQTHaAALJwjEb6w8pVI07mTPn881tAQADAgADeQADNgQ.png" alt="图片"> </p><p>  3.获取 <mark>chat_ID</mark><br>    - 通过<mark>@VersaToolsBot</mark>获取您的频道ID。向该机器人发送消息，按照指示操作，最后您将得到<mark>CHAT_ID</mark>（即频道的ID）。<br>    - 或者通过@GetTheirIDBot获取您的频道ID。向该机器人发送消息，按照指示操作，最后您将得到CHAT_ID（即频道的ID）。</p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADCWiQ2LDIjYergFSk97ZpLUKrE0EdAAJ1yTEbMbKIVN_1cAnqIHVKAQADAgADeAADNgQ.png" alt="图片"></p><p>  最后去Cloudflare Pages后台设置相关的环境变量（注：修改环境变量后，需要重新部署才能生效）</p><table><thead><tr><th align="center">环境变量</th><th align="center">示例值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">TG_Bot_Token</td><td align="center">123468:AAxxxGKrn5</td><td align="center">从@BotFather获取的Telegram Bot Token。</td></tr><tr><td align="center">TG_Chat_ID</td><td align="center">-1234567</td><td align="center">频道的ID，确保TG Bot是该频道或群组的管理员。</td></tr></tbody></table><h2 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h2><h3 id="提前准备"><a href="#提前准备" class="headerlink" title="提前准备"></a>提前准备</h3><p>  你唯一需要提前准备的就是一个<mark>Cloudflare</mark>账户，如果你还没有，请先注册一个。</p><h3 id="部署教程："><a href="#部署教程：" class="headerlink" title="部署教程："></a>部署教程：</h3><p>  简单3步，即可部署本项目，拥有自己的图床</p><p>  1.下载或Fork本仓库 (注意：目前请使用fork) <a href="https://github.com/cf-pages/Telegraph-Image">【仓库链接】</a></p><p>  2.打开Cloudflare Dashboard，进入Pages管理页面，选择创建项目，如果在第一步中选择的是fork本仓库，则选择<code>连接到 Git 提供程序</code>，如果第一步中选择的是下载本仓库则选择<code>直接上传</code> </p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADCmiQ33qFa_AzNIGUVZ7WrSp7WFnBAAKGyTEbMbKIVGNcpNiiFTBMAQADAgADeQADNgQ.png" alt="图片"></p><p>  3.按照页面提示输入项目名称，选择需要连接的git仓库（第一步选择的是fork）或是上传刚刚下载的仓库文件（第一步选择的是下载本仓库），点击<code>部署站点</code>即可完成部署</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>  1.无限图片储存数量，你可以上传不限数量的图片</p><p>  2.无需购买服务器，托管于Cloudflare的网络上，当使用量不超过Cloudflare的免费额度时，完全免费</p><p>  3.无需购买域名，可以使用Cloudflare Pages提供的<code>*.pages.dev</code>的免费二级域名，同时也支持绑定自定义域名</p><p>  4.支持图片审查API，可根据需要开启，开启后不良图片将自动屏蔽，不再加载</p><p>  5.支持后台图片管理，可以对上传的图片进行在线预览，添加白名单，黑名单等操作</p><h3 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h3><p>  在pages的自定义域里面，绑定cloudflare中存在的域名，在cloudflare托管的域名，自动会修改dns记录 </p><p>  <img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADC2iQ4JplNukEqbHiF0wn8sacV9JrAAKHyTEbMbKIVLwGKUtYn9UYAQADAgADeQADNgQ.png" alt="图片"></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>  1.由于图片文件实际存储于Telegraph，Telegraph限制上传的图片大小最大为5MB</p><p>  2.由于使用Cloudflare的网络，图片的加载速度在某些地区可能得不到保证</p><p>  3.Cloudflare Function免费版每日限制100,000个请求（即上传或是加载图片的总次数不能超过100,000次）, 正常使用已经足够！</p><hr><p>  ✧･ﾟ: <em>✧･ﾟ:</em>  <strong>END</strong>    <em>:･ﾟ✧</em>:･ﾟ✧</p>]]></content>
      
      
      <categories>
          
          <category> 技术类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web式云端电脑？</title>
      <link href="/article/Web%E5%BC%8F%E4%BA%91%E7%AB%AF%E7%94%B5%E8%84%91%EF%BC%9F/"/>
      <url>/article/Web%E5%BC%8F%E4%BA%91%E7%AB%AF%E7%94%B5%E8%84%91%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="无需魔法访问-Google-！堪称Web式的云端电脑？"><a href="#无需魔法访问-Google-！堪称Web式的云端电脑？" class="headerlink" title="无需魔法访问 Google ！堪称Web式的云端电脑？"></a>无需魔法访问 Google ！堪称Web式的云端电脑？</h1><p>无需“魔法”就能访问 Google ？关键时期开源当作备用，查资料方便， 堪称Web式的云端电脑！<br><img src="https://telegraph-image-dp7.pages.dev/file/AgACAgUAAyEGAASgAAGGzAADBWiDttXlcjYtusuJH2OfjUNCpKv4AAIMxjEb6w8hVMoVnJ5vSAdoAQADAgADdwADNgQ.jpg" alt="图片"></p><p>Dustinbrett平台：<a href="https://dustinbrett.com/">链接直达</a></p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/article/hello-world%20copy/"/>
      <url>/article/hello-world%20copy/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>fuck you you you</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 博客配置</title>
      <link href="/article/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/"/>
      <url>/article/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>log-js.pug 这个文件是控制台修改文件</p><p>1.安装主题<br>1.1. Git 安裝<br>在博客根目录里安装最新版主题</p><p>git clone -b main <a href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git">https://github.com/anzhiyu-c/hexo-theme-anzhiyu.git</a> themes&#x2F;anzhiyu<br>第一次使用需要安装 pug 以及 stylus 的渲染器</p><p>npm install hexo-renderer-pug hexo-renderer-stylus –save</p><p>1.2. 应用主题</p><p>修改 hexo 配置文件_config.yml，把主题改为anzhiyu</p><p>theme: anzhiyu<br>1.3. 覆盖配置<br>覆盖配置可以使主题配置放置在 anzhiyu 目录之外，避免在更新主题时丢失自定义的配置。</p><p>如果你是linux系统就执行以下命令</p><p>cp -rf .&#x2F;themes&#x2F;anzhiyu&#x2F;_config.yml .&#x2F;_config.anzhiyu.yml<br>如果你是windows系统就请手动将&#x2F;themes&#x2F;anzhiyu&#x2F;_config.yml复制到根目录下并重命名为_config.anzhiyu.yml即可。</p><p>以后如果修改任何主题配置，都只需修改 _config.anzhiyu.yml 的配置即可。</p><p>注意：</p><p>只要存在于 _config.anzhiyu.yml 的配置都是高优先级，修改原 _config.yml 是无效的。<br>每次更新主题可能存在配置变更，请注意更新说明，可能需要手动对 _config.anzhiyu.yml 同步修改。<br>想查看覆盖配置有没有生效，可以通过 hexo g –debug 查看命令行输出。<br>如果想将某些配置覆盖为空，注意不要把主键删掉，不然是无法覆盖的<br>1.4. 配置主题与主站配置文件</p><p>到这一步主题部署就完成了，就是这么简单！！！</p><p>&#x2F;&#x2F;本地预览<br>hexo cl; hexo s</p><p>&#x2F;&#x2F;推送更新上线<br>hexo cl; hexo g; hexo d<br>1.5. 生成标签页和分类页<br>执行以下命令生成标签页</p><p>hexo new page tags<br>找到 source&#x2F;tags&#x2F;index.md 这个文件，修改添加 type: “tags”</p><p>执行以下命令生成分类页<br>hexo new page categories<br>找到 source&#x2F;categories&#x2F;index.md 这个文件，修改添加 type: “categories”</p><p>剩下的工作就是配置_config.yml和_config.anzhiyu.yml文件，修改博客参数。</p><ol start="2"><li>配置文章模版</li></ol><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style><p>page.md模版，仅供参考</p><hr><h2 id="title-【必需】页面标题date-【必需】页面创建日期type-【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置updated-【可选】页面更新日期comments-【可选】显示页面评论模块-默认-true-description-【可选】页面描述keywords-【可选】页面关键字top-img-https-img-090227-xyz-file-ae62475a131f3734a201c-png-【可选】页面顶部图片mathjax-【可选】显示-mathjax-当设置-mathjax-的-per-page-false-时，才需要配置，默认-false-katex-【可选】显示-katex-当设置-katex-的-per-page-false-时，才需要配置，默认-false-aside-【可选】显示侧边栏-默认-true-aplayer-【可选】在需要的页面加载-aplayer-的-js-和-css-请参考文章下面的音乐-配置highlight-shrink-【可选】配置代码框是否展开-true-false-默认为设置中-highlight-shrink-的配置-top-single-background-【可选】部分页面的顶部模块背景图片"><a href="#title-【必需】页面标题date-【必需】页面创建日期type-【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置updated-【可选】页面更新日期comments-【可选】显示页面评论模块-默认-true-description-【可选】页面描述keywords-【可选】页面关键字top-img-https-img-090227-xyz-file-ae62475a131f3734a201c-png-【可选】页面顶部图片mathjax-【可选】显示-mathjax-当设置-mathjax-的-per-page-false-时，才需要配置，默认-false-katex-【可选】显示-katex-当设置-katex-的-per-page-false-时，才需要配置，默认-false-aside-【可选】显示侧边栏-默认-true-aplayer-【可选】在需要的页面加载-aplayer-的-js-和-css-请参考文章下面的音乐-配置highlight-shrink-【可选】配置代码框是否展开-true-false-默认为设置中-highlight-shrink-的配置-top-single-background-【可选】部分页面的顶部模块背景图片" class="headerlink" title="title:  #【必需】页面标题date:  #【必需】页面创建日期type: #【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置updated: #【可选】页面更新日期comments: #【可选】显示页面评论模块(默认 true)description: #【可选】页面描述keywords: #【可选】页面关键字top_img: https://img.090227.xyz/file/ae62475a131f3734a201c.png #【可选】页面顶部图片mathjax: #【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)katex: #【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)aside: #【可选】显示侧边栏 (默认 true)aplayer: #【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置highlight_shrink: #【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)top_single_background: #【可选】部分页面的顶部模块背景图片"></a>title: hexo 博客配置 #【必需】页面标题<br>date: 1753293248000 #【必需】页面创建日期<br>type: #【必需】标签、分类、关于、音乐馆、友情链接、相册、相册详情、朋友圈、即刻页面需要配置<br>updated: #【可选】页面更新日期<br>comments: #【可选】显示页面评论模块(默认 true)<br>description: #【可选】页面描述<br>keywords: #【可选】页面关键字<br>top_img: <a href="https://img.090227.xyz/file/ae62475a131f3734a201c.png">https://img.090227.xyz/file/ae62475a131f3734a201c.png</a> #【可选】页面顶部图片<br>mathjax: #【可选】显示 mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false)<br>katex: #【可选】显示 katex(当设置 katex 的 per_page: false 时，才需要配置，默认 false)<br>aside: #【可选】显示侧边栏 (默认 true)<br>aplayer: #【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置<br>highlight_shrink: #【可选】配置代码框是否展开(true&#x2F;false)(默认为设置中 highlight_shrink 的配置)<br>top_single_background: #【可选】部分页面的顶部模块背景图片</h2><p>更多功能</p><p>新建文章<br>新建博文命令<br>hexo new 这是一篇新的博文<br>新建标签页命令<br>hexo new page 新建的标签页<br>文章置顶</p><p>安装插件<br>npm install hexo-generator-topindex –save<br>设置置顶<br>给需要置顶的文章加入top参数，如下：</p><hr><h2 id="title-每天一个linux命令date-2017-01-23-11-41-48top-1categories-运维tags-linux命令"><a href="#title-每天一个linux命令date-2017-01-23-11-41-48top-1categories-运维tags-linux命令" class="headerlink" title="title: 每天一个linux命令date: 2017-01-23 11:41:48top: 1categories:- 运维tags:- linux命令"></a>title: 每天一个linux命令<br>date: 2017-01-23 11:41:48<br>top: 1<br>categories:<br>- 运维<br>tags:<br>- linux命令</h2><p>如果存在多个置顶文章，top后的参数越大，越靠前。</p><p>开启本地搜索</p><p>安装插件<br>你需要安装 hexo-generator-search，根据它的文档去做相应配置</p><p>npm install hexo-generator-search –save<br>设置主题配置文件<br>local_search:<br>  enable: true<br>  preload: false<br>  CDN:<br>参数解释<br>enable是否开启本地搜索<br>preload预加载，开启后，进入网页后会自动加载搜索文件。关闭时，只有点击搜索按钮后，才会加载搜索文件<br>CDN搜索文件的 CDN 地址（默认使用的本地链接）<br>添加任意文件</p><p>例如当我们想在网站根目录添加ads.txt文件，来通过站长验证时，我们只需要在&#x2F;source文件夹下放置该文件即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为啥会焦虑？</title>
      <link href="/article/%E4%B8%BA%E5%95%A5%E4%BC%9A%E7%84%A6%E8%99%91%EF%BC%9F/"/>
      <url>/article/%E4%B8%BA%E5%95%A5%E4%BC%9A%E7%84%A6%E8%99%91%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="为啥会焦虑？"><a href="#为啥会焦虑？" class="headerlink" title="为啥会焦虑？"></a><strong>为啥会焦虑？</strong></h1><ol><li>如果你是一个没心没肺的，你是不会焦虑的，正是因为你想变得更好你才会焦虑，所以这个情绪很正常，每个人都有，正确看待就好，但是不要过量</li><li>不要尝试去控制任何一件事情</li><li>降低期待</li></ol><h1 id="如何保持快乐呢？"><a href="#如何保持快乐呢？" class="headerlink" title="如何保持快乐呢？"></a><del>如何保持快乐呢？</del></h1><ul><li>1.意识到我们人生没有什么事情是永久的，包括你的烦恼</li><li>2.学会感恩  </li><li>3.问问自己 什么是好  什么是坏？都是别人定义的<br>所以你要真正思考你自己想要的是什么，而不是别人或者社会为你定义的，你要明确自己想要的是什么？</li></ul><h1 id="Markdown写法"><a href="#Markdown写法" class="headerlink" title="Markdown写法"></a>Markdown写法</h1><blockquote><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号</p><blockquote><p>这是区块嵌套的第二层</p><blockquote><p>这是区块嵌套的第三层    </p></blockquote></blockquote></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代码表示</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&#x27;RUNOOB&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>这个链接用 runoob 作为网址变量 <a href="http://www.runoob.com/">Runoob</a><br>然后在文档的结尾为变量赋值（网址）</p><p><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本"><br><img src="/%E5%9B%BE%E7%89%87%E5%9C%B0%E5%9D%80" alt="alt 属性文本" title="可选标题"><br><img src="https://static.jyshare.com/images/runoob-logo.png" alt="RUNOOB 图标"><br><img src="https://static.jyshare.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB"></p><p>$$<br>\begin{Bmatrix}<br>   a &amp; b \<br>   c &amp; d<br>\end{Bmatrix}<br>$$<br>$$<br>\begin{CD}<br>   A @&gt;a&gt;&gt; B \<br>@VbVV @AAcA \<br>   C @&#x3D; D<br>\end{CD}<br>$$</p><div class="video-container">[up主专用，视频内嵌代码贴在这]</div><style>.video-container {    position: relative;    width: 100%;    padding-top: 56.25%; /* 16:9 aspect ratio (height/width = 9/16 * 100%) */}.video-container iframe {    position: absolute;    top: 0;    left: 0;    width: 100%;    height: 100%;}</style>]]></content>
      
      
      <categories>
          
          <category> 心理学类别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理学 </tag>
            
            <tag> 养生 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
